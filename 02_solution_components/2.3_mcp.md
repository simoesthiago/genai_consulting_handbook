# MODEL CONTEXT PROTOCOL (MCP)

**Goal:** Standardize how AI applications connect to external data sources and tools, enabling centralized governance, security, and catalog management for enterprise GenAI deployments.

**Prerequisites:**
- [`../01-foundations/1.1_llm_fundamentals.md`](../01-foundations/1.1_llm_fundamentals.md) — Understanding LLM capabilities
- [`2.2_tool_calling.md`](./2.2_tool_calling.md) — Understanding tool calling basics
- [`../01-foundations/1.2_prompt_engineering.md`](../01-foundations/1.2_prompt_engineering.md) — How LLMs interact with tools

**Related:**
- [`2.2_tool_calling.md`](./2.2_tool_calling.md) — MCP builds on tool calling concepts
- [`agentic_ai.md`](./agentic_ai.md) — MCP in agentic systems
- [`guardrails.md`](./guardrails.md) — Security controls for MCP servers
- [`../06-risk-governance-ethics/data_privacy_and_security.md`](../06-risk-governance-ethics/data_privacy_and_security.md) — Governance and access control

---

## TL;DR (30 seconds)

- **MCP standardizes how AI applications connect to external systems** (databases, APIs, tools) through a protocol layer
- **Enables centralized governance** — one catalog of all available integrations, controlled access, audit logging
- **Critical for enterprise AI deployments** with multiple applications needing the same integrations (avoid duplication, ensure security)
- **MCP servers** expose specific tools/data in a standardized way, like "universal adapters" for AI applications
- **Key value:** Standardization + governance + security, not just technical capability

---

## What's In / What's Out

**In:**
- MCP protocol overview and architecture
- Governance patterns (authentication, catalog, permissions)
- MCP server design and implementation
- Comparison with direct tool calling (when to use MCP vs direct integration)
- Comprehensive case study with decision rationale

**Out:**
- Detailed MCP protocol specification (technical spec details)
- Specific MCP server implementation code (language/framework-specific)
- Advanced multi-agent coordination using MCP (covered in [`multi_agent_systems.md`](./multi_agent_systems.md))
- Detailed prompt engineering for MCP (covered in [`prompt_engineering.md`](../01-foundations/1.2_prompt_engineering.md))

---

## 1. WHAT IS MCP / PROBLEM IT SOLVES

### 1.1. What is MCP?

**Definition:** Model Context Protocol (MCP) is a standardized protocol that defines how AI applications connect to external data sources and tools. Think of MCP as a "universal adapter" for AI integrations—just like how a universal power adapter lets you plug devices into different outlets around the world, MCP lets AI applications connect to different systems in a standardized way.

**Simple analogy:** 
- **Without MCP:** Each AI application builds its own custom connection to every system (like each device needing its own custom power plug)
- **With MCP:** All AI applications use the same standardized protocol to connect to systems (like using a universal adapter)

**Key insight:** MCP doesn't replace tool calling—it standardizes and governs it. Tool calling is the mechanism (how LLMs call functions), MCP is the protocol layer that standardizes how those tools are exposed and accessed.

### 1.2. The Problem MCP Solves

**The challenge:** In enterprise environments, you often have multiple AI applications that need to access the same external systems (CRM, ERP, databases, APIs). Without standardization, each application:

1. **Duplicates integration code:** Each app builds its own connection to Salesforce, SAP, etc.
2. **No centralized governance:** Hard to track what integrations exist, who has access, what's being used
3. **Security risks:** Each app implements its own authentication, access control, audit logging (inconsistent, error-prone)
4. **Maintenance burden:** When an API changes, you update code in multiple places
5. **No visibility:** Can't see which apps are using which integrations, making it hard to optimize or secure

**Real-world example:**
- Company has 5 AI applications (customer support bot, sales assistant, HR copilot, finance assistant, IT helpdesk)
- All 5 need to access Salesforce CRM
- Without MCP: Each app has its own Salesforce integration code, its own API keys, its own error handling
- With MCP: One MCP server exposes Salesforce tools/data, all 5 apps connect to it using the same protocol

**MCP solution:**
- **Standardization:** One protocol for all integrations
- **Centralized governance:** One catalog of all MCP servers (what's available, who owns it, what it does)
- **Security:** Centralized authentication, permissions, audit logging
- **Reusability:** One MCP server can serve multiple AI applications
- **Maintainability:** Update integration once, all apps benefit

### 1.3. Why MCP Matters for Enterprises

**"So what?" for enterprise:**

1. **Cost reduction:** Avoid duplicating integration code across applications (one MCP server vs N custom integrations)
2. **Security and compliance:** Centralized access control, audit logging, security reviews (easier to meet compliance requirements)
3. **Operational efficiency:** One place to monitor, update, and maintain integrations
4. **Risk management:** Visibility into what integrations exist, who uses them, what data flows through them
5. **Scalability:** Add new AI applications without rebuilding integrations (just connect to existing MCP servers)

**Decision it enables:**
- "Should we build a custom integration or use an MCP server?" → Use MCP if multiple apps need it
- "How do we govern AI integrations?" → MCP catalog + permissions
- "How do we ensure security across all AI apps?" → Centralized MCP security controls

---

## 2. MCP ARCHITECTURE

```
┌─────────────────┐      ┌─────────────────┐      ┌─────────────────┐
│  AI Application │      │  AI Application │      │  AI Application │
│   (Customer     │      │   (Sales        │      │   (HR Copilot)  │
│   Support Bot)  │      │   Assistant)    │      │                 │
└────────┬────────┘      └────────┬────────┘      └────────┬────────┘
         │                        │                        │
         │                        │                        │
         └────────────────────────┼────────────────────────┘
                                  │
                                  │ MCP Protocol
                                  │ (Standardized)
                                  │
         ┌────────────────────────┼────────────────────────┐
         │                        │                        │
         ▼                        ▼                        ▼
┌─────────────────┐      ┌─────────────────┐      ┌─────────────────┐
│   MCP Server    │      │   MCP Server    │      │   MCP Server    │
│   (Salesforce)  │      │   (SAP ERP)     │      │   (HR Database) │
└────────┬────────┘      └────────┬────────┘      └────────┬────────┘
         │                        │                        │
         │                        │                        │
         ▼                        ▼                        ▼
┌─────────────────┐      ┌─────────────────┐      ┌─────────────────┐
│   External      │      │   External      │      │   External      │
│   System        │      │   System        │      │   System        │
│   (Salesforce   │      │   (SAP ERP)     │      │   (HR Database) │
│    CRM)         │      │                 │      │                 │
└─────────────────┘      └─────────────────┘      └─────────────────┘
```

### 2.1. Components of MCP Architecture

**1. AI Applications (MCP Clients)**
- Applications that need to access external systems
- Examples: Customer support bot, sales assistant, HR copilot
- Connect to MCP servers using the MCP protocol

**2. MCP Servers**
- Specialized services that expose specific tools/data in a standardized way
- Each MCP server connects to one or more external systems
- Examples: Salesforce MCP server, SAP ERP MCP server, HR Database MCP server
- **Key responsibility:** Translate between MCP protocol and the external system's API

**3. MCP Protocol**
- Standardized communication protocol between AI applications and MCP servers
- Defines: How to discover available tools, how to call tools, how to handle errors, how to authenticate
- **Key benefit:** All AI applications use the same protocol, regardless of which MCP server they connect to

**4. External Systems**
- The actual systems that contain data or perform actions
- Examples: Salesforce CRM, SAP ERP, internal databases, REST APIs
- MCP servers act as "adapters" that translate MCP protocol calls into system-specific API calls

### 2.2. How MCP Differs from Direct Tool Calling

**Direct tool calling (without MCP):**
```
AI Application → Custom Integration Code → External System
```
- Each application has its own integration code
- No standardization (each app implements differently)
- No centralized governance

**MCP-based tool calling:**
```
AI Application → MCP Protocol → MCP Server → External System
```
- All applications use the same protocol
- Standardized integration (MCP server handles system-specific details)
- Centralized governance (catalog, permissions, audit)

**Key differences:**

| Aspect | Direct Tool Calling | MCP-Based |
|--------|-------------------|-----------|
| **Standardization** | Each app implements differently | Standardized protocol |
| **Reusability** | Code duplicated per app | One MCP server serves multiple apps |
| **Governance** | Per-app, decentralized | Centralized catalog and permissions |
| **Security** | Per-app implementation | Centralized authentication/audit |
| **Maintenance** | Update N places when API changes | Update once (MCP server) |
| **Visibility** | Hard to see what integrations exist | Centralized catalog |

---

## 3. WHERE MCP FITS IN ARCHITECTURE

### 3.1. MCP as a Standardization Layer

**Architecture pattern:**
```
┌─────────────────────────────────────────────────────────┐
│              AI Application Layer                        │
│  (Customer Support Bot, Sales Assistant, HR Copilot)   │
└───────────────────────┬─────────────────────────────────┘
                        │
                        │ MCP Protocol (Standardized)
                        │
┌───────────────────────┴─────────────────────────────────┐
│              MCP Layer (Standardization)                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │ MCP Server   │  │ MCP Server  │  │ MCP Server  │   │
│  │ (Salesforce) │  │ (SAP ERP)   │  │ (HR DB)     │   │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘   │
└─────────┼─────────────────┼─────────────────┼─────────┘
          │                 │                 │
          │                 │                 │
┌─────────┴─────────────────┴─────────────────┴─────────┐
│         External Systems Layer                          │
│  (Salesforce CRM, SAP ERP, HR Database, APIs)          │
└─────────────────────────────────────────────────────────┘
```

**MCP's role:** MCP sits between AI applications and external systems, providing:
- **Standardization:** All apps use the same protocol
- **Abstraction:** Apps don't need to know system-specific API details
- **Governance:** Centralized catalog, permissions, audit

### 3.2. When to Use MCP vs Direct Integration

**Use MCP when:**
- **Multiple applications need the same integration:** If 2+ AI apps need Salesforce, use MCP (avoid duplication)
- **You need centralized governance:** Security, audit, permissions must be centralized
- **Integration is complex:** MCP server handles complexity, apps just use the protocol
- **You want visibility:** Need to track what integrations exist, who uses them
- **Enterprise scale:** Many applications, many integrations, need standardization

**Use direct integration when:**
- **Single application, one-time integration:** Only one app needs it, won't be reused
- **Very simple integration:** Direct API call is simpler than MCP overhead
- **Prototype/MVP:** Speed matters more than standardization (can migrate to MCP later)
- **Tight coupling required:** Application needs direct, low-latency access (rare)

**Decision framework:**
```
Will 2+ applications need this integration?
│
├─ YES → Use MCP ✅
│  (Standardize, reuse, govern)
│
└─ NO → Is governance/security critical?
   │
   ├─ YES → Use MCP ✅
   │  (Even for single app, MCP provides governance)
   │
   └─ NO → Direct integration OK
      (Simple, one-time, prototype)
```

### 3.3. MCP in the Broader Architecture

**Full stack view:**
```
User → AI Application → MCP Protocol → MCP Server → External System
       (LLM + Tools)   (Standardized)  (Adapter)    (CRM/ERP/DB)
```

**Where MCP fits:**
- **Above:** AI applications (consumers of MCP)
- **Below:** External systems (what MCP connects to)
- **Alongside:** Other integration patterns (direct API calls for non-AI apps)

**Integration with other patterns:**
- **RAG + MCP:** RAG retrieves knowledge, MCP performs actions (complementary)
- **Tool calling + MCP:** MCP standardizes how tools are exposed (MCP is the protocol layer for tool calling)
- **Multi-agent + MCP:** Multiple agents can share MCP servers (standardized access)

---

## 4. GOVERNANCE: AUTHENTICATION, CATALOG, PERMISSIONS

Governance is MCP's primary value proposition for enterprises. This section covers how to manage authentication, maintain a catalog, and control permissions.

### 4.1. Authentication: How MCP Servers Authenticate

**The challenge:** MCP servers need to authenticate with external systems (CRM, ERP, databases). How do they securely store and use credentials?

**Authentication patterns:**

**1. Service Account Authentication**
- MCP server uses a dedicated service account (not a user account)
- Service account has specific permissions (only what the MCP server needs)
- Credentials stored securely (secrets manager, not in code)

**Example:**
```
MCP Server (Salesforce) → Service Account → Salesforce API
                         (stored in AWS Secrets Manager)
```

**Benefits:**
- Dedicated account (not tied to a user)
- Can be rotated independently
- Clear audit trail (service account actions are logged)

***2. OAuth 2.0 / API Keys**
- MCP server uses OAuth tokens or API keys
- Tokens refreshed automatically (OAuth) or rotated periodically (API keys)
- Stored in secrets manager (AWS Secrets Manager, Azure Key Vault, HashiCorp Vault)

**Benefits:**
- Industry-standard authentication
- Automatic token refresh (OAuth)
- Can be revoked/rotated without code changes

**3. Certificate-Based Authentication**
- MCP server uses client certificates
- Certificates stored securely, rotated periodically
- Common for enterprise systems (SAP, internal APIs)

**Best practices:**
- **Never store credentials in code:** Always use secrets manager
- **Rotate credentials regularly:** Service accounts, API keys, certificates
- **Use least privilege:** Service account should only have permissions needed for MCP server's purpose
- **Audit credential usage:** Log when credentials are used, by whom, for what

**Example: Authentication flow**
```
1. AI Application requests access to MCP Server
2. MCP Server checks: Does this application have permission? (from catalog)
3. MCP Server authenticates with external system using stored credentials
4. MCP Server executes request, returns result
5. Audit log: Application X accessed MCP Server Y at time Z
```

### 4.2. Catalog: Centralized Registry of MCP Servers

**The challenge:** In an enterprise with many MCP servers, you need a central registry that answers:
- What MCP servers exist?
- What do they do? (what tools/data do they expose?)
- Who owns them? (who is responsible for maintenance?)
- Who can use them? (which applications have access?)
- What's their status? (active, deprecated, experimental?)

**What is the catalog?** The catalog is like an "app store" for MCP servers—a centralized registry that documents all available MCP servers, their capabilities, ownership, and access controls.

**Catalog components:**

**1. Server metadata:**
- Name, description, purpose
- Owner (team/person responsible)
- Status (active, deprecated, experimental)
- Version, last updated

**2. Capabilities:**
- What tools does this server expose? (list of tools with descriptions)
- What resources does it provide? (data sources, file systems)
- What prompts does it offer? (pre-built prompts for common tasks)

**3. Access control:**
- Which applications can use this server?
- What permissions are required?
- What data classification? (public, internal, confidential)

**4. Technical details:**
- Endpoint URL
- Authentication method
- Rate limits, quotas
- Dependencies (what external systems it connects to)

**5. Operational information:**
- Support contact
- Documentation links
- Known issues, maintenance schedule

**Catalog format (structured data):**
```json
{
  "server_id": "mcp-salesforce-prod",
  "name": "Salesforce CRM MCP Server",
  "description": "Provides access to Salesforce CRM data and operations",
  "owner": "sales-engineering-team",
  "status": "active",
  "version": "1.2.0",
  "capabilities": {
    "tools": [
      {
        "name": "get_account",
        "description": "Retrieves account information by ID"
      },
      {
        "name": "create_opportunity",
        "description": "Creates a new sales opportunity"
      }
    ],
    "resources": [
      {
        "name": "salesforce://accounts",
        "description": "Access to Salesforce accounts"
      }
    ]
  },
  "access_control": {
    "allowed_applications": ["customer-support-bot", "sales-assistant"],
    "required_permissions": ["salesforce.read", "salesforce.write"],
    "data_classification": "confidential"
  },
  "technical": {
    "endpoint": "https://mcp-salesforce.internal.company.com",
    "authentication": "service_account",
    "rate_limit": "100 requests/minute"
  }
}
```

**Catalog management:**
- **Who maintains it?** Central platform team or server owners
- **How is it updated?** When new MCP server is created, owner registers it in catalog
- **How is it accessed?** API, web UI, or configuration file
- **How is it versioned?** Track changes, deprecations, new servers

**Benefits of catalog:**
- **Discoverability:** Developers can find existing MCP servers instead of building new ones
- **Governance:** Centralized view of all integrations
- **Documentation:** Single source of truth for what each server does
- **Access control:** Catalog defines who can use what

### 4.3. Permissions: Controlling Access

**The challenge:** Not all AI applications should have access to all MCP servers. A customer support bot shouldn't access financial systems. An HR copilot shouldn't access customer data. How do you control access?

**Permission models:**

**1. Per-Application Permissions**
- Each AI application has a list of allowed MCP servers
- Example: `customer-support-bot` can access `mcp-salesforce` and `mcp-order-system`, but not `mcp-finance`

**Implementation:**
```yaml
applications:
  customer-support-bot:
    allowed_mcp_servers:
      - mcp-salesforce
      - mcp-order-system
      - mcp-inventory
  hr-copilot:
    allowed_mcp_servers:
      - mcp-hr-database
      - mcp-payroll
      - mcp-benefits
```

**2. Role-Based Permissions**
- Applications have roles (e.g., "customer-facing", "internal", "financial")
- MCP servers require specific roles
- Example: `mcp-finance` requires role `financial-access`

**Implementation:**
```yaml
mcp_servers:
  mcp-finance:
    required_roles:
      - financial-access
      - high-clearance
  mcp-salesforce:
    required_roles:
      - customer-data-access
```

**3. Attribute-Based Access Control (ABAC)**
- Permissions based on attributes (application type, data classification, user context)
- More flexible than role-based
- Example: Application can access MCP server if `application.data_classification >= server.data_classification`

**Permission validation flow:**
```
1. AI Application requests access to MCP Server
2. System checks catalog: Is this server in the application's allowed list?
3. System checks permissions: Does application have required role/attributes?
4. System checks resource-level: Can application access this specific resource?
5. If all checks pass → Allow access
6. If any check fails → Deny access, log attempt
```

**Best practices:**
- **Principle of least privilege:** Applications should only have access to MCP servers they need
- **Regular audits:** Review permissions quarterly, remove unused access
- **Just-in-time access:** Grant temporary access for specific tasks, revoke after
- **Audit logging:** Log all permission checks (who request

- **Audit logging:** Log all permission checks (who requested, what was requested, was it granted/denied, timestamp)

**4. Server Ownership and Responsibility**

**The challenge:** Who is responsible for each MCP server? Who maintains it? Who fixes issues? Who approves access?

**Ownership model:**
- **Owner:** Team/person responsible for the MCP server (development, maintenance, security)
- **Maintainer:** Person who handles day-to-day operations (updates, bug fixes)
- **Security contact:** Person to contact for security issues
- **Approver:** Person who approves new access requests

**Example ownership structure:**
mcp_servers:
  mcp-salesforce:
    owner: sales-engineering-team
    maintainer: john.doe@company.com
    security_contact: security-team@company.com
    approver: sales-engineering-lead@company.com**Responsibilities:**
- **Owner:** Ensures server is maintained, documented, secure
- **Maintainer:** Updates server, fixes bugs, responds to issues
- **Security contact:** Handles security incidents, vulnerability reports
- **Approver:** Reviews and approves access requests

---


## 5. CASE STUDY: IMPLEMENTING MCP IN ENTERPRISE

This case study walks through a complete MCP implementation, explaining the rationale behind each decision.

**Company:** GlobalRetail, 5,000 employees, multinational retailer  
**Problem:** Company has 8 AI applications (customer support bot, sales assistant, inventory manager, HR copilot, finance assistant, IT helpdesk, marketing copilot, warehouse assistant) that need to access 12 external systems (Salesforce CRM, SAP ERP, HR database, inventory system, payment processor, shipping APIs, email system, document storage, analytics platform, customer database, supplier portal, compliance system). Each application was building its own integrations, leading to code duplication, security inconsistencies, and maintenance burden.  
**Goal:** Standardize all AI integrations using MCP, create centralized governance, reduce integration code duplication by 80%, improve security posture.  
**Constraints:** $50K budget, 12-week timeline, zero downtime migration, must maintain existing functionality, compliance requirements (GDPR, PCI-DSS).

---

### 5.1. Decision: MCP vs Direct Integration

**The challenge:** Should we use MCP for all integrations, or keep some as direct integrations?

**Analysis:**
- 8 applications need access to 12 systems
- Many systems are used by multiple applications (Salesforce used by 5 apps, SAP by 4 apps)
- Security and compliance are critical (customer data, financial data)
- Need centralized governance for audit and compliance

**Decision:** Use MCP for all integrations used by 2+ applications, direct integration only for single-app, simple integrations.

**Rationale:**
- MCP provides standardization and governance (critical for compliance)
- Reduces code duplication (80% of integrations are shared)
- Centralized security controls (easier to audit, secure)
- Even single-app integrations benefit from MCP governance (catalog, permissions)

**Trade-offs:**
- ✅ Standardization, governance, security
- ✅ Reduced duplication, easier maintenance
- ⚠️ Initial setup overhead (but pays off long-term)
- ⚠️ Slight latency overhead (MCP layer adds ~10-20ms, acceptable)

**Alternative considered:** Keep direct integrations for single-app use cases - rejected because even single-app integrations benefit from MCP governance (catalog, audit, security).

### 5.2. MCP Server Design Decisions

**The challenge:** How should we organize MCP servers? One server per external system? Or group related systems?

**Analysis:**
- 12 external systems, 8 applications
- Some systems are related (e.g., payment processor + shipping API both used for orders)
- Some systems have different access patterns (read-only vs read-write)
- Need to balance granularity (fine-grained control) vs simplicity (fewer servers to manage)

**Decision:** One MCP server per external system (12 MCP servers total).

**Rationale:**
- **Clear ownership:** Each system has clear owner (Salesforce team owns Salesforce MCP server)
- **Independent scaling:** Each server can scale independently based on usage
- **Security boundaries:** Each server has its own authentication, permissions, audit
- **Simpler maintenance:** Update one server when external system API changes
- **Clearer catalog:** Catalog entry maps 1:1 to external system

**Trade-offs:**
- ✅ Clear ownership, independent scaling, security boundaries
- ✅ Simpler to understand and maintain
- ⚠️ More servers to manage (12 vs fewer grouped servers)
- ⚠️ Applications may need to connect to multiple servers (but MCP protocol handles this)

**Alternative considered:** Group related systems (e.g., "Order Management MCP Server" for payment + shipping) - rejected because different systems have different owners, security requirements, and update cycles.

### 5.3. Governance Model

**The challenge:** How should we structure governance? Centralized platform team? Distributed ownership?

**Analysis:**
- Need centralized catalog and permissions (for governance)
- But system owners know their systems best (for maintenance)
- Need clear responsibilities (who does what?)

**Decision:** Hybrid model: Centralized platform team manages catalog and permissions, system owners maintain their MCP servers.

**Rationale:**
- **Platform team:** Manages catalog, permissions, security policies, audit
- **System owners:** Develop, maintain, update their MCP servers
- **Clear separation:** Platform = governance, Owners = implementation
- **Accountability:** System owners responsible for their servers' security and maintenance

**Implementation:**
- **Platform team:** Maintains catalog, approves new MCP servers, sets security policies, manages permissions
- **System owners:** Register servers in catalog, maintain code, respond to issues, update documentation
- **Approval process:** New MCP servers require platform team approval (security review)

**Trade-offs:**
- ✅ Clear responsibilities, accountability
- ✅ System owners have autonomy (can update their servers)
- ✅ Centralized governance (platform team ensures consistency)
- ⚠️ Requires coordination (platform team + system owners)

**Alternative considered:** Fully centralized (platform team owns all servers) - rejected because system owners know their systems better, and centralized team would be bottleneck.

### 5.4. Security Controls

**The challenge:** How should we secure MCP servers? Authentication, encryption, audit logging?

**Analysis:**
- Compliance requirements (GDPR, PCI-DSS) require strong security
- Multiple applications accessing sensitive data (customer data, financial data)
- Need audit trail for compliance

**Decision:** Comprehensive security: Service accounts, secrets manager, TLS encryption, comprehensive audit logging, data classification.

**Rationale:**
- **Service accounts:** Each MCP server uses dedicated service account (not user accounts)
- **Secrets manager:** All credentials stored in AWS Secrets Manager (encrypted, rotated)
- **TLS 1.3:** All communication encrypted in transit
- **Audit logging:** Log all tool calls (who, what, when, result) for compliance
- **Data classification:** Tag servers with classification (public, internal, confidential, restricted)
- **Access control:** Applications can only access servers with matching/lower classification

**Implementation:**
- **Authentication:** OAuth 2.0 for external APIs, service accounts for databases
- **Credential storage:** AWS Secrets Manager (automated rotation every 90 days)
- **Encryption:** TLS 1.3 for all MCP protocol communication
- **Audit logging:** Centralized logging system (all tool calls logged, PII redacted)
- **Data classification:** Catalog tags each server with classification

**Trade-offs:**
- ✅ Strong security, compliance-ready
- ✅ Centralized audit trail
- ⚠️ More complex setup (but necessary for enterprise)
- ⚠️ Credential rotation overhead (but automated)

**Alternative considered:** Simpler security (API keys in config files) - rejected because doesn't meet compliance requirements.

### 5.5. Catalog Management

**The challenge:** How should we maintain the catalog? Manual documentation? Automated? What format?

**Analysis:**
- 12 MCP servers to document
- Need to keep catalog up-to-date (servers change over time)
- Need to be accessible to developers (discoverability)
- Need to support automation (applications need to query catalog)

**Decision:** Automated catalog with manual review: YAML files in Git repository, automated validation, web UI for browsing.

**Rationale:**
- **YAML files in Git:** Version-controlled, easy to edit, supports automation
- **Automated validation:** CI/CD validates catalog entries (required fields, format)
- **Web UI:** Human-readable interface for browsing catalog
- **API:** Applications can query catalog programmatically
- **Review process:** Changes require PR review (platform team approves)

**Implementation:**
- **Catalog format:** YAML files (one per MCP server) in Git repository
- **Validation:** CI/CD pipeline validates YAML structure, required fields
- **Web UI:** Internal wiki displays catalog (generated from YAML)
- **API:** REST API for applications to query catalog
- **Review:** PR process for catalog changes (platform team reviews)

**Trade-offs:**
- ✅ Version-controlled, automated validation
- ✅ Human-readable (YAML) and machine-readable (API)
- ✅ Review process ensures quality
- ⚠️ Requires discipline (teams must update catalog when servers change)

**Alternative considered:** Fully manual (wiki pages) - rejected because doesn't support automation, harder to keep in sync.

### 5.6. Migration Strategy

**The challenge:** How do we migrate 8 applications from direct integrations to MCP without downtime?

**Analysis:**
- 8 applications currently using direct integrations
- Can't have downtime (customer-facing applications)
- Need to maintain existing functionality
- Migration must be gradual (can't do all at once)

**Decision:** Gradual migration: Build MCP servers in parallel, migrate applications one at a time, feature flags for rollback.

**Rationale:**
- **Parallel development:** Build MCP servers while applications still use direct integrations (no disruption)
- **One at a time:** Migrate applications gradually (lower risk)
- **Feature flags:** Use feature flags to switch between direct integration and MCP (easy rollback)
- **Validation:** Test MCP servers thoroughly before migration
- **Rollback plan:** Can rollback to direct integration if issues arise

**Migration steps:**
1. **Week 1-4:** Build MCP servers (in parallel with existing integrations)
2. **Week 5-6:** Test MCP servers (load testing, integration testing)
3. **Week 7-10:** Migrate applications one at a time (start with low-risk apps)
4. **Week 11-12:** Monitor, fix issues, complete migration

**Trade-offs:**
- ✅ Zero downtime, gradual migration
- ✅ Easy rollback if issues
- ⚠️ Takes longer (12 weeks vs faster "big bang" migration)
- ⚠️ Temporary duplication (direct + MCP during migration)

**Alternative considered:** "Big bang" migration (all at once) - rejected because too risky, no rollback option.

### 5.7. End-to-End Flow Example

**Scenario:** Customer support bot needs to check order status and process a refund for order #12345.

#### 5.7.1. Before MCP (Direct Integration)

**Flow:**
1. User asks: "Check status of order #12345 and process a refund if it's eligible"
2. Customer support bot has **hardcoded Salesforce API integration**
3. Bot directly calls Salesforce API: `GET /services/data/v58.0/sobjects/Order/12345`
4. Bot directly calls Salesforce API: `POST /services/data/v58.0/sobjects/Refund/` with order details
5. Bot responds to user with order status and refund confirmation

**Problems:**
- Each application has its own Salesforce integration code (duplication)
- No centralized governance (who has access? what permissions?)
- No audit trail (hard to track what was accessed)
- Security risks (API keys scattered across applications)
- Hard to update (change in Salesforce API requires updating all applications)

#### 5.7.2. After MCP (Standardized Integration)

**Flow:**
1. User asks: "Check status of order #12345 and process a refund if it's eligible"
2. Customer support bot queries MCP catalog: "What servers can access Salesforce?"
3. Catalog returns: `mcp-salesforce-prod` server available
4. Bot connects to MCP server: `mcp-salesforce-prod`
5. Bot calls tool: `get_order(order_id="12345")` via MCP protocol
6. MCP server authenticates (service account), calls Salesforce API, returns order data
7. Bot calls tool: `process_refund(order_id="12345", amount=null)` via MCP protocol
8. MCP server validates permissions, processes refund, returns confirmation
9. Bot responds to user with order status and refund confirmation
10. **All tool calls logged** in centralized audit system

**Benefits:**
- Standardized interface (all apps use same MCP server)
- Centralized governance (catalog shows who can access what)
- Complete audit trail (all tool calls logged)
- Secure (credentials in secrets manager, not in code)
- Easy to update (change MCP server, all apps benefit)

#### 5.7.3. Example MCP Server Catalog Entry

**MCP Server: Salesforce CRM**

**Server ID:** `mcp-salesforce-prod`

**Purpose:** Provides standardized access to Salesforce CRM data and operations for AI applications.

**Owner:** Sales Engineering Team  
**Maintainer:** john.doe@company.com  
**Security Contact:** security-team@company.com  
**Status:** Active

**Resources:**
- `salesforce://accounts` - Access to Salesforce account records
- `salesforce://opportunities` - Access to sales opportunities
- `salesforce://contacts` - Access to contact records
- `salesforce://orders` - Access to order records

**Tools:**
- `get_order(order_id)` - Retrieves order information by ID
- `search_orders(query)` - Searches orders by customer, date, status
- `process_refund(order_id, amount)` - Processes refund for an order
- `get_account(account_id)` - Retrieves account information by ID
- `create_opportunity(name, account_id, amount, stage)` - Creates a new sales opportunity

**Permissions:**
- Allowed applications: `customer-support-bot`, `sales-assistant`, `marketing-copilot`
- Required roles: `salesforce.read`, `salesforce.write`
- Data classification: Confidential

**Security:**
- Authentication method: OAuth 2.0 (service account)
- Credential storage: AWS Secrets Manager
- Encryption: TLS 1.3 in transit, encrypted at rest
- Audit logging: Yes (all tool calls, parameters sanitized, user/app tracked)

**Technical Details:**
- Endpoint: `https://mcp-salesforce.internal.company.com`
- Rate limits: 100 requests/minute per application
- Dependencies: Salesforce API (production instance)
- Version: 1.2.0

**Documentation:** https://wiki.company.com/mcp/salesforce  
**Support:** #mcp-salesforce Slack channel

---

## NEXT STEPS

**Recommended reading:**
- [`2.2_tool_calling.md`](./2.2_tool_calling.md) — Understanding tool calling basics that MCP builds upon
- [`agentic_ai.md`](./agentic_ai.md) — Using MCP in agentic AI systems
- [`guardrails.md`](./guardrails.md) — Security controls and validation for MCP servers
- [`../06-risk-governance-ethics/data_privacy_and_security.md`](../06-risk-governance-ethics/data_privacy_and_security.md) — Governance, IAM, and compliance for MCP
- [`multi_agent_systems.md`](./multi_agent_systems.md) — Multi-agent systems using shared MCP servers